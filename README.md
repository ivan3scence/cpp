# Основные правила работы

# Отслеживайте выход за пределы массива
Предусматривайте в коде проверку на выход за пределы массива. Особенно связано с приходом сигналов, по которым должны отрисовываться иконки. Решать эту проблему можно следующими способами:

* ставить значение по умолчанию - например самую первую иконку. Тогда в случае чего этот баг будет явно обнаружен
* игнорировать и выходить из функции.

Если это не предусмотреть то в дальнейшем расширение принесет одни только хлопоты. трату времени на то. что б найти нужный кусок кода для доработки.


# Проверяйте ресурсы, подгружаемые из xml
Не всегда перечень иконок может быть равен количеству сигналов или параметров.
Типичная ситуация запись по детектору. В данном случае videoworker в любом случае
генерирует событие по детектору о том что стартует запись. А qtmenu должна игнорировать, так как в qtmenu не должна отображаться иконка записи. Поэтому нет 
смысла вводить какую либо иконку в xml-файл. тогда возможна ситуация что:

1. не подгрузилась иконка - она и не должна быть. 
2. пришел сигнал меню о записи по детектору
3. в функции не анализируется что иконки нет и начинает выводить
4. приложение обвалилось  

Поэтому перед тем как рисовать - проверяем. 
Другими словами не доверяем своему собственному коду и тем более другим разработчикам, которые всегда могут впихнуть параметры выходящие за пределы допустимого



# Инструкции по разработке типовых задач в меню.

## Добавление нового индикатора
### шаг0. Добавляем сами иконки
Добавляем иконки в ресурсы проекта 

### шаг1. Добавление описания в xml-файл
Находим уже подходящие наработки индикатора. Либо пишем с нуля. например `detector`

### шаг2. Реализуем модуль в каталоге indicators/.
В модуле реализуется класс, который обычно имеет следующее поведение:

* имеется конструктор в котором подгружаются иконки из xml, устанавливаются начальные состояния, и идет подключение по dbus
* переопределяется метод paintEvent  в котором идет отрисовка иконки средствами qt
* имеется обработчик, который вызывается по событию dbus

В качестве пример можно посмотреть реализацию индикатора `detector`

### Шаг3. Подключаем индикатор

Для этого в модуле `panel.cpp` в методе `hashTable()` прописывам наш класс как
метообъект.

### Шаг 4. Дорабатываем поведение в `panel.cpp`
Если это неоходимо



## Добавление нового элемента в меню

### шаг 0. Добавляем иконки меню
Добавляем иконки в ресурсы проекта

### шаг 1. Прописываем меню в xml-файле
По аналогии с другими ветками меню добавляем параметры. При этом учитываем следующие факторы:
Топология меню достаточно простая. структура состоит из пунктов. типичное начало меню

		<menu name="clip_menu">
		    <!--<textbar>Насадка</textbar>-->
		    <item type="next">
		        <name>Тип вирт. сетки</name>
		        <icon>:/res/res/icons/type_grid.png</icon>
		        <nexticon>:/res/res/icons/next_item.png</nexticon>
		        <valuename>type_grid_clip</valuename>
		        <childmenu>type_grid</childmenu>
		    </item>
		</menu>    

Атрибут `name` задает название ветки меню. далше идут item-ы у которых количество параметров зависит от его типа. Лучше поискать аналогичное описание.
Базовые параметры которые есть у всех элементов.

* `type` тип элемента - как отражается. Смотри перечень классов в каталоге `menuitems_core`
* `icon`  путь к отображаемой иконки
* `valuename`  имя параметра - см далее
* `childmenu`  дочернее меню



#### Вложенные подменю.(`childmenu`)
 у меняю может быть вложенное меню. 
Тогда в клавном меню идет ссылка на имя дочерней ветки. в таком случае в параметре `childmenu` прописываем дочернее меню. И меню с данным именем должно быть в описанном файле
например 

	   <item type="next">
	        <name>Тип вирт. сетки</name>
	        <icon>:/res/res/icons/type_grid.png</icon>
	        <nexticon>:/res/res/icons/next_item.png</nexticon>
	        <valuename>type_grid_clip</valuename>
	        <childmenu>type_grid</childmenu>
	    </item>

тогда в xml-файле должно быть объявлено меню 

	 <!-- подменю "тип прицельной сетки" -->
	 <menu name="type_grid">
	    <!--<textbar>Тип прицельной сетки</textbar>-->
	    <item type="radiobutton">
	      <name>Mil-Dot</name> 
	      
	      
#### именование пунктов меню (`valuename`)

Имена меню задаются не от фонаря. Схема именования такая. Допустим в ini-файле, хде хрянятся настройки есть такая секция

	[detector]
	image_size=31
	powered_on=0
	sensitivity=71
	time_interval=3

Она описывает параметры детектора движения

И для того что б меню корректно работало с этипи параметрами нужно задавть имя по следующей схеме

  	 %имя секции%_%имя параметра%
  	 
  	 
То есть будет в итоге вот так
	
		<menu name="detector_sensitivity">
			<item type="slider">
				<name>Чувствительность детектора</name>
				<minvalue>0</minvalue>
				<maxvalue>100</maxvalue>
				<valuename>detector_sensitivity</valuename>  //!!!!!
			 </item>
			 
		</menu>
		<menu name="detector_image_size">
			<item type="slider">
				<name>Размер</name>
				<minvalue>0</minvalue>
				<maxvalue>100</maxvalue>
				<valuename>detector_image_size</valuename>  //!!!!!
			 </item>
		</menu>

В дальнешем это имя разлачивается на две части

* target   - будет имя сецкии
* param  - параметр
 
 Это принцип реализован в модуле `widget` в методах
 
	QString Widget::getTargetFromName(const QString &name)
	QString Widget::getPropertyFromName(const QString &name)
	QString Widget::getValueWrapper(QString name)
        void Widget::setValueWrapper(QString name, QVariant value)

 Каждая группа (target, имя секции) параметров может хранится либо в профилях, либо в хранилище независимом от профилей. Место хранения определяется в классе GenericConfig в методе initMap(), пример
 map_target.insert(DETECTOR_CONFIG_GROUP,Profile); // Группа параметров детектора движений хранится в профилях
 map_target.insert(WIND_CONFIG_GROUP,Global); // Параметры ветра хранятся независимо от профилей

 ### Шаг 2. Добавление имен параметров и dbus-сигналов
Прежде всего неоходимо задать константы в библиотеке `teplovisorcommon`  в модуле `co_config.h` имя новой секции (если необходимо) и имя новых параметров
Далее необходимо выставить эти значения по умолчанию. для этого неоходимо в репозитории рецептов найти каталог с профилями и вставить туда новые секции/параметры
путь примерно такой к профилям `/meta-iwt/recipes-qt/qt-run/qt-app-init-nozzle/profiles/`. 

Если необходимо что б генерировались события по применению параметра - то необходимо еще описать и сигналы в библиотеке  `teplovisorcommon`  в модуле `dbus_interfaces.h`. dbus команда формируется опят же исходня из выбранного меню. поэтому dbus-сообщения нужно формировать по шаблону

	set_%имя параметра%
 
 например если есть параметр у детектора `sensivity`, то dbus команда тогда должна быть как `set_sensivity`
 Смотри по аналогии

### Шаг 3. Обработчики для отсылки сигналов по изменению

Для того что бы генерировались сигналы по изменению параметра их нужно прописать в методе 

	void Widget::setValueWrapper(QString name, QVariant value)
смотри реализацию и делай по аналогии

 Если настройку(или это просто обработчик события) писать\читать из профилей\глобальных параметров не нужно, то сбрасываем флаг isNeed{Read|Write}Setting


### Шаг 4. Расширяем возможности меню через `part_*`

Если реализация сводится не только к реализации параметров меню а и более серьезным функционалом. то скорее всего работы должны провестить следующие:

* создается каталоге part_%предметна область% и туда складываются обособленно все исходники
* если создаются новые виды элементов меню, то они запихыватся в `menuitems_ext` 

находим наиоблее простой по восприятию аналог и смотрим как там все делается



